"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apiActions: () => (/* binding */ apiActions),\n/* harmony export */   apiMatches: () => (/* binding */ apiMatches),\n/* harmony export */   apiPlayers: () => (/* binding */ apiPlayers),\n/* harmony export */   apiRequest: () => (/* binding */ apiRequest),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   getPendingRequests: () => (/* binding */ getPendingRequests),\n/* harmony export */   initializeOfflineSupport: () => (/* binding */ initializeOfflineSupport),\n/* harmony export */   setupOfflineSync: () => (/* binding */ setupOfflineSync),\n/* harmony export */   syncPendingRequests: () => (/* binding */ syncPendingRequests)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n\n// Klucz do przechowywania oczekujących żądań w localStorage\nconst PENDING_REQUESTS_KEY = 'packing_analyzer_pending_requests';\n// Sprawdzenie, czy aplikacja jest online\nconst isOnline = ()=>{\n    return navigator.onLine;\n};\n// Obsługa żądań API z mechanizmem offline\nconst apiRequest = async function(url) {\n    let method = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'GET', body = arguments.length > 2 ? arguments[2] : void 0;\n    // Jeśli jesteśmy online, wysyłamy żądanie normalnie\n    if (isOnline()) {\n        try {\n            const options = {\n                method,\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            };\n            if (body && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {\n                options.body = JSON.stringify(body);\n            }\n            const response = await fetch(url, options);\n            if (!response.ok) {\n                throw new Error(\"API error: \".concat(response.status));\n            }\n            return response.json();\n        } catch (error) {\n            console.error('API request failed:', error);\n            // Jeśli żądanie nie powiodło się (np. z powodu nagłej utraty połączenia),\n            // zapisujemy je do oczekujących żądań\n            if (method !== 'GET') {\n                savePendingRequest(url, method, body);\n            }\n            throw error;\n        }\n    } else {\n        // Jeśli jesteśmy offline i jest to żądanie modyfikujące dane\n        if (method !== 'GET') {\n            savePendingRequest(url, method, body);\n            // Zwracamy mock odpowiedzi\n            return {\n                success: true,\n                offline: true,\n                message: 'Żądanie zostało zapisane i zostanie wysłane, gdy połączenie zostanie przywrócone'\n            };\n        } else {\n            // Dla operacji GET możemy próbować pobrać dane z cache\n            throw new Error('Brak połączenia z internetem. Operacje odczytu nie są dostępne w trybie offline.');\n        }\n    }\n};\n// Zapisanie oczekującego żądania do localStorage\nconst savePendingRequest = (url, method, body)=>{\n    const pendingRequests = getPendingRequests();\n    const newRequest = {\n        id: (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(),\n        url,\n        method,\n        body,\n        timestamp: Date.now()\n    };\n    pendingRequests.push(newRequest);\n    localStorage.setItem(PENDING_REQUESTS_KEY, JSON.stringify(pendingRequests));\n    console.log(\"Zapisano żądanie offline: \".concat(method, \" \").concat(url));\n};\n// Pobranie listy oczekujących żądań\nconst getPendingRequests = ()=>{\n    const requestsJson = localStorage.getItem(PENDING_REQUESTS_KEY);\n    return requestsJson ? JSON.parse(requestsJson) : [];\n};\n// Synchronizacja oczekujących żądań po przywróceniu połączenia\nconst syncPendingRequests = async ()=>{\n    if (!isOnline()) {\n        console.log('Nie można zsynchronizować żądań: brak połączenia');\n        return;\n    }\n    const pendingRequests = getPendingRequests();\n    if (pendingRequests.length === 0) {\n        return;\n    }\n    console.log(\"Rozpoczęto synchronizację \".concat(pendingRequests.length, \" oczekujących żądań\"));\n    // Sortujemy żądania według znacznika czasu\n    const sortedRequests = [\n        ...pendingRequests\n    ].sort((a, b)=>a.timestamp - b.timestamp);\n    // Tworzymy nową listę oczekujących żądań, aktualizowaną w przypadku niepowodzeń\n    const newPendingRequests = [];\n    for (const request of sortedRequests){\n        try {\n            const options = {\n                method: request.method,\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            };\n            if (request.body) {\n                options.body = JSON.stringify(request.body);\n            }\n            const response = await fetch(request.url, options);\n            if (!response.ok) {\n                throw new Error(\"API error: \".concat(response.status));\n            }\n            console.log(\"Zsynchronizowano żądanie: \".concat(request.method, \" \").concat(request.url));\n        } catch (error) {\n            console.error(\"Nie udało się zsynchronizować żądania: \".concat(request.method, \" \").concat(request.url), error);\n            // Zachowaj żądanie, które nie powiodło się, do kolejnej próby\n            newPendingRequests.push(request);\n        }\n    }\n    // Zapisz zaktualizowaną listę oczekujących żądań\n    localStorage.setItem(PENDING_REQUESTS_KEY, JSON.stringify(newPendingRequests));\n    if (newPendingRequests.length === 0) {\n        console.log('Wszystkie żądania zostały zsynchronizowane');\n    } else {\n        console.log(\"Pozostało \".concat(newPendingRequests.length, \" żądań do synchronizacji\"));\n    }\n};\n// Nasłuchiwanie zmiany stanu połączenia\nconst setupOfflineSync = ()=>{\n    if (true) {\n        window.addEventListener('online', ()=>{\n            console.log('Przywrócono połączenie. Rozpoczynam synchronizację.');\n            syncPendingRequests();\n        });\n        window.addEventListener('offline', ()=>{\n            console.log('Utracono połączenie. Aplikacja działa w trybie offline.');\n        });\n    }\n};\n// Sprawdzanie i synchronizacja przy starcie aplikacji\nconst initializeOfflineSupport = ()=>{\n    setupOfflineSync();\n    // Jeśli jesteśmy online przy starcie aplikacji, spróbujmy zsynchronizować oczekujące żądania\n    if (isOnline()) {\n        syncPendingRequests();\n    }\n};\n// Specjalistyczne funkcje API\nconst apiActions = {\n    // Pobieranie akcji dla określonego meczu\n    getActions: (matchId)=>{\n        const url = matchId ? \"/api/actions?matchId=\".concat(matchId) : '/api/actions';\n        return apiRequest(url, 'GET');\n    },\n    // Zapisywanie nowej akcji\n    saveAction: (actionData)=>{\n        return apiRequest('/api/actions', 'POST', actionData);\n    },\n    // Usuwanie akcji\n    deleteAction: (actionId)=>{\n        return apiRequest(\"/api/actions/\".concat(actionId), 'DELETE');\n    },\n    // Usuwanie wszystkich akcji dla meczu\n    deleteAllActions: (matchId)=>{\n        return apiRequest(\"/api/actions?matchId=\".concat(matchId), 'DELETE');\n    }\n};\nconst apiMatches = {\n    // Pobieranie meczów dla określonego zespołu\n    getMatches: (teamId)=>{\n        const url = teamId ? \"/api/matches?teamId=\".concat(teamId) : '/api/matches';\n        return apiRequest(url, 'GET');\n    },\n    // Zapisywanie nowego meczu\n    saveMatch: (matchData)=>{\n        return apiRequest('/api/matches', 'POST', matchData);\n    },\n    // Usuwanie meczu\n    deleteMatch: (matchId)=>{\n        return apiRequest(\"/api/matches/\".concat(matchId), 'DELETE');\n    }\n};\nconst apiPlayers = {\n    // Pobieranie zawodników dla określonego zespołu\n    getPlayers: (teamId)=>{\n        const url = teamId ? \"/api/players?teamId=\".concat(teamId) : '/api/players';\n        return apiRequest(url, 'GET');\n    },\n    // Zapisywanie nowego zawodnika\n    savePlayer: (playerData)=>{\n        return apiRequest('/api/players', 'POST', playerData);\n    },\n    // Aktualizacja zawodnika\n    updatePlayer: (playerId, playerData)=>{\n        return apiRequest(\"/api/players/\".concat(playerId), 'PUT', playerData);\n    },\n    // Usuwanie zawodnika\n    deletePlayer: (playerId)=>{\n        return apiRequest(\"/api/players/\".concat(playerId), 'DELETE');\n    }\n};\n// Eksportujemy API\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n    apiRequest,\n    getPendingRequests,\n    syncPendingRequests,\n    initializeOfflineSupport,\n    setupOfflineSync,\n    apiActions,\n    apiMatches,\n    apiPlayers\n});\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtJQUN6QkMsY0FBYyxDQUFDQyxVQUFrQkY7UUFDL0IsT0FBTy9ELFdBQVcsZ0JBQXlCLE9BQVRpRSxXQUFZLE9BQU9GO0lBQ3ZEO0lBRUEscUJBQXFCO0lBQ3JCRyxjQUFjLENBQUNEO1FBQ2IsT0FBT2pFLFdBQVcsZ0JBQXlCLE9BQVRpRSxXQUFZO0lBQ2hEO0FBQ0YsRUFBRTtBQUVGLG1CQUFtQjtBQUNuQixpRUFBZTtJQUNiakU7SUFDQXFCO0lBQ0FhO0lBQ0FXO0lBQ0FIO0lBQ0FJO0lBQ0FRO0lBQ0FNO0FBQ0YsQ0FBQyxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbHVrYXN6ZmVyc3p0L0Rvd25sb2Fkcy9wYWNraW5nLWFuYWx5emVyL3NyYy9saWIvYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gJ3V1aWQnO1xuXG4vLyBTdHJ1a3R1cmEgcHJ6ZWNob3d5d2FuaWEgb2N6ZWt1asSFY3ljaCBha2NqaVxuaW50ZXJmYWNlIFBlbmRpbmdSZXF1ZXN0IHtcbiAgaWQ6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBib2R5PzogYW55O1xuICB0aW1lc3RhbXA6IG51bWJlcjtcbn1cblxuLy8gS2x1Y3ogZG8gcHJ6ZWNob3d5d2FuaWEgb2N6ZWt1asSFY3ljaCDFvMSFZGHFhCB3IGxvY2FsU3RvcmFnZVxuY29uc3QgUEVORElOR19SRVFVRVNUU19LRVkgPSAncGFja2luZ19hbmFseXplcl9wZW5kaW5nX3JlcXVlc3RzJztcblxuLy8gU3ByYXdkemVuaWUsIGN6eSBhcGxpa2FjamEgamVzdCBvbmxpbmVcbmNvbnN0IGlzT25saW5lID0gKCkgPT4ge1xuICByZXR1cm4gbmF2aWdhdG9yLm9uTGluZTtcbn07XG5cbi8vIE9ic8WCdWdhIMW8xIVkYcWEIEFQSSB6IG1lY2hhbml6bWVtIG9mZmxpbmVcbmV4cG9ydCBjb25zdCBhcGlSZXF1ZXN0ID0gYXN5bmMgPFQ+KFxuICB1cmw6IHN0cmluZyxcbiAgbWV0aG9kOiBzdHJpbmcgPSAnR0VUJyxcbiAgYm9keT86IGFueVxuKTogUHJvbWlzZTxUPiA9PiB7XG4gIC8vIEplxZtsaSBqZXN0ZcWbbXkgb25saW5lLCB3eXN5xYJhbXkgxbzEhWRhbmllIG5vcm1hbG5pZVxuICBpZiAoaXNPbmxpbmUoKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvcHRpb25zOiBSZXF1ZXN0SW5pdCA9IHtcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIGlmIChib2R5ICYmIChtZXRob2QgPT09ICdQT1NUJyB8fCBtZXRob2QgPT09ICdQVVQnIHx8IG1ldGhvZCA9PT0gJ1BBVENIJykpIHtcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSByZXF1ZXN0IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAvLyBKZcWbbGkgxbzEhWRhbmllIG5pZSBwb3dpb2TFgm8gc2nEmSAobnAuIHogcG93b2R1IG5hZ8WCZWogdXRyYXR5IHBvxYLEhWN6ZW5pYSksXG4gICAgICAvLyB6YXBpc3VqZW15IGplIGRvIG9jemVrdWrEhWN5Y2ggxbzEhWRhxYRcbiAgICAgIGlmIChtZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICAgIHNhdmVQZW5kaW5nUmVxdWVzdCh1cmwsIG1ldGhvZCwgYm9keSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSmXFm2xpIGplc3RlxZtteSBvZmZsaW5lIGkgamVzdCB0byDFvMSFZGFuaWUgbW9keWZpa3VqxIVjZSBkYW5lXG4gICAgaWYgKG1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgIHNhdmVQZW5kaW5nUmVxdWVzdCh1cmwsIG1ldGhvZCwgYm9keSk7XG4gICAgICAvLyBad3JhY2FteSBtb2NrIG9kcG93aWVkemlcbiAgICAgIHJldHVybiB7IFxuICAgICAgICBzdWNjZXNzOiB0cnVlLCBcbiAgICAgICAgb2ZmbGluZTogdHJ1ZSwgXG4gICAgICAgIG1lc3NhZ2U6ICfFu8SFZGFuaWUgem9zdGHFgm8gemFwaXNhbmUgaSB6b3N0YW5pZSB3eXPFgmFuZSwgZ2R5IHBvxYLEhWN6ZW5pZSB6b3N0YW5pZSBwcnp5d3LDs2NvbmUnIFxuICAgICAgfSBhcyB1bmtub3duIGFzIFQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERsYSBvcGVyYWNqaSBHRVQgbW/FvGVteSBwcsOzYm93YcSHIHBvYnJhxIcgZGFuZSB6IGNhY2hlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JyYWsgcG/FgsSFY3plbmlhIHogaW50ZXJuZXRlbS4gT3BlcmFjamUgb2Rjenl0dSBuaWUgc8SFIGRvc3TEmXBuZSB3IHRyeWJpZSBvZmZsaW5lLicpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gWmFwaXNhbmllIG9jemVrdWrEhWNlZ28gxbzEhWRhbmlhIGRvIGxvY2FsU3RvcmFnZVxuY29uc3Qgc2F2ZVBlbmRpbmdSZXF1ZXN0ID0gKHVybDogc3RyaW5nLCBtZXRob2Q6IHN0cmluZywgYm9keT86IGFueSkgPT4ge1xuICBjb25zdCBwZW5kaW5nUmVxdWVzdHM6IFBlbmRpbmdSZXF1ZXN0W10gPSBnZXRQZW5kaW5nUmVxdWVzdHMoKTtcblxuICBjb25zdCBuZXdSZXF1ZXN0OiBQZW5kaW5nUmVxdWVzdCA9IHtcbiAgICBpZDogdXVpZHY0KCksXG4gICAgdXJsLFxuICAgIG1ldGhvZCxcbiAgICBib2R5LFxuICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgfTtcblxuICBwZW5kaW5nUmVxdWVzdHMucHVzaChuZXdSZXF1ZXN0KTtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oUEVORElOR19SRVFVRVNUU19LRVksIEpTT04uc3RyaW5naWZ5KHBlbmRpbmdSZXF1ZXN0cykpO1xuICBcbiAgY29uc29sZS5sb2coYFphcGlzYW5vIMW8xIVkYW5pZSBvZmZsaW5lOiAke21ldGhvZH0gJHt1cmx9YCk7XG59O1xuXG4vLyBQb2JyYW5pZSBsaXN0eSBvY3pla3VqxIVjeWNoIMW8xIVkYcWEXG5leHBvcnQgY29uc3QgZ2V0UGVuZGluZ1JlcXVlc3RzID0gKCk6IFBlbmRpbmdSZXF1ZXN0W10gPT4ge1xuICBjb25zdCByZXF1ZXN0c0pzb24gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShQRU5ESU5HX1JFUVVFU1RTX0tFWSk7XG4gIHJldHVybiByZXF1ZXN0c0pzb24gPyBKU09OLnBhcnNlKHJlcXVlc3RzSnNvbikgOiBbXTtcbn07XG5cbi8vIFN5bmNocm9uaXphY2phIG9jemVrdWrEhWN5Y2ggxbzEhWRhxYQgcG8gcHJ6eXdyw7NjZW5pdSBwb8WCxIVjemVuaWFcbmV4cG9ydCBjb25zdCBzeW5jUGVuZGluZ1JlcXVlc3RzID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBpZiAoIWlzT25saW5lKCkpIHtcbiAgICBjb25zb2xlLmxvZygnTmllIG1vxbxuYSB6c3luY2hyb25pem93YcSHIMW8xIVkYcWEOiBicmFrIHBvxYLEhWN6ZW5pYScpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHBlbmRpbmdSZXF1ZXN0cyA9IGdldFBlbmRpbmdSZXF1ZXN0cygpO1xuICBpZiAocGVuZGluZ1JlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnNvbGUubG9nKGBSb3pwb2N6xJl0byBzeW5jaHJvbml6YWNqxJkgJHtwZW5kaW5nUmVxdWVzdHMubGVuZ3RofSBvY3pla3VqxIVjeWNoIMW8xIVkYcWEYCk7XG5cbiAgLy8gU29ydHVqZW15IMW8xIVkYW5pYSB3ZWTFgnVnIHpuYWN6bmlrYSBjemFzdVxuICBjb25zdCBzb3J0ZWRSZXF1ZXN0cyA9IFsuLi5wZW5kaW5nUmVxdWVzdHNdLnNvcnQoKGEsIGIpID0+IGEudGltZXN0YW1wIC0gYi50aW1lc3RhbXApO1xuICBcbiAgLy8gVHdvcnp5bXkgbm93xIUgbGlzdMSZIG9jemVrdWrEhWN5Y2ggxbzEhWRhxYQsIGFrdHVhbGl6b3dhbsSFIHcgcHJ6eXBhZGt1IG5pZXBvd29kemXFhFxuICBjb25zdCBuZXdQZW5kaW5nUmVxdWVzdHM6IFBlbmRpbmdSZXF1ZXN0W10gPSBbXTtcblxuICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2Ygc29ydGVkUmVxdWVzdHMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3B0aW9uczogUmVxdWVzdEluaXQgPSB7XG4gICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgICAgaWYgKHJlcXVlc3QuYm9keSkge1xuICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LmJvZHkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QudXJsLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKGBac3luY2hyb25pem93YW5vIMW8xIVkYW5pZTogJHtyZXF1ZXN0Lm1ldGhvZH0gJHtyZXF1ZXN0LnVybH1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgTmllIHVkYcWCbyBzacSZIHpzeW5jaHJvbml6b3dhxIcgxbzEhWRhbmlhOiAke3JlcXVlc3QubWV0aG9kfSAke3JlcXVlc3QudXJsfWAsIGVycm9yKTtcbiAgICAgIC8vIFphY2hvd2FqIMW8xIVkYW5pZSwga3TDs3JlIG5pZSBwb3dpb2TFgm8gc2nEmSwgZG8ga29sZWpuZWogcHLDs2J5XG4gICAgICBuZXdQZW5kaW5nUmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICB9XG4gIH1cblxuICAvLyBaYXBpc3ogemFrdHVhbGl6b3dhbsSFIGxpc3TEmSBvY3pla3VqxIVjeWNoIMW8xIVkYcWEXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFBFTkRJTkdfUkVRVUVTVFNfS0VZLCBKU09OLnN0cmluZ2lmeShuZXdQZW5kaW5nUmVxdWVzdHMpKTtcbiAgXG4gIGlmIChuZXdQZW5kaW5nUmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgY29uc29sZS5sb2coJ1dzenlzdGtpZSDFvMSFZGFuaWEgem9zdGHFgnkgenN5bmNocm9uaXpvd2FuZScpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKGBQb3pvc3RhxYJvICR7bmV3UGVuZGluZ1JlcXVlc3RzLmxlbmd0aH0gxbzEhWRhxYQgZG8gc3luY2hyb25pemFjamlgKTtcbiAgfVxufTtcblxuLy8gTmFzxYJ1Y2hpd2FuaWUgem1pYW55IHN0YW51IHBvxYLEhWN6ZW5pYVxuZXhwb3J0IGNvbnN0IHNldHVwT2ZmbGluZVN5bmMgPSAoKSA9PiB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnUHJ6eXdyw7Njb25vIHBvxYLEhWN6ZW5pZS4gUm96cG9jenluYW0gc3luY2hyb25pemFjasSZLicpO1xuICAgICAgc3luY1BlbmRpbmdSZXF1ZXN0cygpO1xuICAgIH0pO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnVXRyYWNvbm8gcG/FgsSFY3plbmllLiBBcGxpa2FjamEgZHppYcWCYSB3IHRyeWJpZSBvZmZsaW5lLicpO1xuICAgIH0pO1xuICB9XG59O1xuXG4vLyBTcHJhd2R6YW5pZSBpIHN5bmNocm9uaXphY2phIHByenkgc3RhcmNpZSBhcGxpa2FjamlcbmV4cG9ydCBjb25zdCBpbml0aWFsaXplT2ZmbGluZVN1cHBvcnQgPSAoKSA9PiB7XG4gIHNldHVwT2ZmbGluZVN5bmMoKTtcbiAgXG4gIC8vIEplxZtsaSBqZXN0ZcWbbXkgb25saW5lIHByenkgc3RhcmNpZSBhcGxpa2FjamksIHNwcsOzYnVqbXkgenN5bmNocm9uaXpvd2HEhyBvY3pla3VqxIVjZSDFvMSFZGFuaWFcbiAgaWYgKGlzT25saW5lKCkpIHtcbiAgICBzeW5jUGVuZGluZ1JlcXVlc3RzKCk7XG4gIH1cbn07XG5cbi8vIFNwZWNqYWxpc3R5Y3puZSBmdW5rY2plIEFQSVxuZXhwb3J0IGNvbnN0IGFwaUFjdGlvbnMgPSB7XG4gIC8vIFBvYmllcmFuaWUgYWtjamkgZGxhIG9rcmXFm2xvbmVnbyBtZWN6dVxuICBnZXRBY3Rpb25zOiAobWF0Y2hJZD86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHVybCA9IG1hdGNoSWQgPyBgL2FwaS9hY3Rpb25zP21hdGNoSWQ9JHttYXRjaElkfWAgOiAnL2FwaS9hY3Rpb25zJztcbiAgICByZXR1cm4gYXBpUmVxdWVzdCh1cmwsICdHRVQnKTtcbiAgfSxcblxuICAvLyBaYXBpc3l3YW5pZSBub3dlaiBha2NqaVxuICBzYXZlQWN0aW9uOiAoYWN0aW9uRGF0YTogYW55KSA9PiB7XG4gICAgcmV0dXJuIGFwaVJlcXVlc3QoJy9hcGkvYWN0aW9ucycsICdQT1NUJywgYWN0aW9uRGF0YSk7XG4gIH0sXG5cbiAgLy8gVXN1d2FuaWUgYWtjamlcbiAgZGVsZXRlQWN0aW9uOiAoYWN0aW9uSWQ6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiBhcGlSZXF1ZXN0KGAvYXBpL2FjdGlvbnMvJHthY3Rpb25JZH1gLCAnREVMRVRFJyk7XG4gIH0sXG5cbiAgLy8gVXN1d2FuaWUgd3N6eXN0a2ljaCBha2NqaSBkbGEgbWVjenVcbiAgZGVsZXRlQWxsQWN0aW9uczogKG1hdGNoSWQ6IHN0cmluZykgPT4ge1xuICAgIHJldHVybiBhcGlSZXF1ZXN0KGAvYXBpL2FjdGlvbnM/bWF0Y2hJZD0ke21hdGNoSWR9YCwgJ0RFTEVURScpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYXBpTWF0Y2hlcyA9IHtcbiAgLy8gUG9iaWVyYW5pZSBtZWN6w7N3IGRsYSBva3JlxZtsb25lZ28gemVzcG/FgnVcbiAgZ2V0TWF0Y2hlczogKHRlYW1JZD86IHN0cmluZykgPT4ge1xuICAgIGNvbnN0IHVybCA9IHRlYW1JZCA/IGAvYXBpL21hdGNoZXM/dGVhbUlkPSR7dGVhbUlkfWAgOiAnL2FwaS9tYXRjaGVzJztcbiAgICByZXR1cm4gYXBpUmVxdWVzdCh1cmwsICdHRVQnKTtcbiAgfSxcblxuICAvLyBaYXBpc3l3YW5pZSBub3dlZ28gbWVjenVcbiAgc2F2ZU1hdGNoOiAobWF0Y2hEYXRhOiBhbnkpID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdCgnL2FwaS9tYXRjaGVzJywgJ1BPU1QnLCBtYXRjaERhdGEpO1xuICB9LFxuXG4gIC8vIFVzdXdhbmllIG1lY3p1XG4gIGRlbGV0ZU1hdGNoOiAobWF0Y2hJZDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIGFwaVJlcXVlc3QoYC9hcGkvbWF0Y2hlcy8ke21hdGNoSWR9YCwgJ0RFTEVURScpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgYXBpUGxheWVycyA9IHtcbiAgLy8gUG9iaWVyYW5pZSB6YXdvZG5pa8OzdyBkbGEgb2tyZcWbbG9uZWdvIHplc3BvxYJ1XG4gIGdldFBsYXllcnM6ICh0ZWFtSWQ/OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCB1cmwgPSB0ZWFtSWQgPyBgL2FwaS9wbGF5ZXJzP3RlYW1JZD0ke3RlYW1JZH1gIDogJy9hcGkvcGxheWVycyc7XG4gICAgcmV0dXJuIGFwaVJlcXVlc3QodXJsLCAnR0VUJyk7XG4gIH0sXG5cbiAgLy8gWmFwaXN5d2FuaWUgbm93ZWdvIHphd29kbmlrYVxuICBzYXZlUGxheWVyOiAocGxheWVyRGF0YTogYW55KSA9PiB7XG4gICAgcmV0dXJuIGFwaVJlcXVlc3QoJy9hcGkvcGxheWVycycsICdQT1NUJywgcGxheWVyRGF0YSk7XG4gIH0sXG5cbiAgLy8gQWt0dWFsaXphY2phIHphd29kbmlrYVxuICB1cGRhdGVQbGF5ZXI6IChwbGF5ZXJJZDogc3RyaW5nLCBwbGF5ZXJEYXRhOiBhbnkpID0+IHtcbiAgICByZXR1cm4gYXBpUmVxdWVzdChgL2FwaS9wbGF5ZXJzLyR7cGxheWVySWR9YCwgJ1BVVCcsIHBsYXllckRhdGEpO1xuICB9LFxuXG4gIC8vIFVzdXdhbmllIHphd29kbmlrYVxuICBkZWxldGVQbGF5ZXI6IChwbGF5ZXJJZDogc3RyaW5nKSA9PiB7XG4gICAgcmV0dXJuIGFwaVJlcXVlc3QoYC9hcGkvcGxheWVycy8ke3BsYXllcklkfWAsICdERUxFVEUnKTtcbiAgfVxufTtcblxuLy8gRWtzcG9ydHVqZW15IEFQSVxuZXhwb3J0IGRlZmF1bHQge1xuICBhcGlSZXF1ZXN0LFxuICBnZXRQZW5kaW5nUmVxdWVzdHMsXG4gIHN5bmNQZW5kaW5nUmVxdWVzdHMsXG4gIGluaXRpYWxpemVPZmZsaW5lU3VwcG9ydCxcbiAgc2V0dXBPZmZsaW5lU3luYyxcbiAgYXBpQWN0aW9ucyxcbiAgYXBpTWF0Y2hlcyxcbiAgYXBpUGxheWVyc1xufTsgIl0sIm5hbWVzIjpbInY0IiwidXVpZHY0IiwiUEVORElOR19SRVFVRVNUU19LRVkiLCJpc09ubGluZSIsIm5hdmlnYXRvciIsIm9uTGluZSIsImFwaVJlcXVlc3QiLCJ1cmwiLCJtZXRob2QiLCJib2R5Iiwib3B0aW9ucyIsImhlYWRlcnMiLCJKU09OIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJjb25zb2xlIiwic2F2ZVBlbmRpbmdSZXF1ZXN0Iiwic3VjY2VzcyIsIm9mZmxpbmUiLCJtZXNzYWdlIiwicGVuZGluZ1JlcXVlc3RzIiwiZ2V0UGVuZGluZ1JlcXVlc3RzIiwibmV3UmVxdWVzdCIsImlkIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInB1c2giLCJsb2NhbFN0b3JhZ2UiLCJzZXRJdGVtIiwibG9nIiwicmVxdWVzdHNKc29uIiwiZ2V0SXRlbSIsInBhcnNlIiwic3luY1BlbmRpbmdSZXF1ZXN0cyIsImxlbmd0aCIsInNvcnRlZFJlcXVlc3RzIiwic29ydCIsImEiLCJiIiwibmV3UGVuZGluZ1JlcXVlc3RzIiwicmVxdWVzdCIsInNldHVwT2ZmbGluZVN5bmMiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiaW5pdGlhbGl6ZU9mZmxpbmVTdXBwb3J0IiwiYXBpQWN0aW9ucyIsImdldEFjdGlvbnMiLCJtYXRjaElkIiwic2F2ZUFjdGlvbiIsImFjdGlvbkRhdGEiLCJkZWxldGVBY3Rpb24iLCJhY3Rpb25JZCIsImRlbGV0ZUFsbEFjdGlvbnMiLCJhcGlNYXRjaGVzIiwiZ2V0TWF0Y2hlcyIsInRlYW1JZCIsInNhdmVNYXRjaCIsIm1hdGNoRGF0YSIsImRlbGV0ZU1hdGNoIiwiYXBpUGxheWVycyIsImdldFBsYXllcnMiLCJzYXZlUGxheWVyIiwicGxheWVyRGF0YSIsInVwZGF0ZVBsYXllciIsInBsYXllcklkIiwiZGVsZXRlUGxheWVyIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});